const e=[{title:"",headers:[],path:"/timeline.html",content:""},{title:"",headers:[],path:"/posts.html",content:""},{title:"",headers:[],path:"/friendship-link.html",content:""},{title:"",headers:[],path:"/categories/git/1.html",content:""},{title:"",headers:[],path:"/categories/react/1.html",content:""},{title:"",headers:[],path:"/categories/java/1.html",content:""},{title:"",headers:[],path:"/categories/qita/1.html",content:""},{title:"",headers:[],path:"/categories/javajichu/1.html",content:""},{title:"",headers:[],path:"/categories/javajichu/2.html",content:""},{title:"",headers:[],path:"/tags/Git/1.html",content:""},{title:"",headers:[],path:"/tags/xiangmuguanli/1.html",content:""},{title:"",headers:[],path:"/tags/React/1.html",content:""},{title:"",headers:[],path:"/tags/xiaoxiduilie/1.html",content:""},{title:"",headers:[],path:"/tags/xingnenyouhua/1.html",content:""},{title:"",headers:[],path:"/tags/shejimoshi/1.html",content:""},{title:"",headers:[],path:"/tags/TypeScript/1.html",content:""},{title:"",headers:[],path:"/tags/java/1.html",content:""},{title:"",headers:[],path:"/tags/fangfuceng/1.html",content:""},{title:"",headers:[],path:"/tags/shejisixiang/1.html",content:""},{title:"",headers:[],path:"/tags/VuePress/1.html",content:""},{title:"",headers:[],path:"/tags/vuepress-theme-reco/1.html",content:""},{title:"",headers:[],path:"/tags/bokeyouhua/1.html",content:""},{title:"",headers:[],path:"/tags/Java/1.html",content:""},{title:"",headers:[],path:"/tags/Java/2.html",content:""},{title:"",headers:[],path:"/tags/shuzu/1.html",content:""},{title:"",headers:[],path:"/tags/zifuchuan/1.html",content:""},{title:"",headers:[],path:"/tags/jihekuangjia/1.html",content:""},{title:"",headers:[],path:"/tags/rongqi/1.html",content:""},{title:"",headers:[],path:"/tags/yichangchuli/1.html",content:""},{title:"",headers:[],path:"/tags/yichangfenlei/1.html",content:""},{title:"",headers:[],path:"/tags/zuijiashijian/1.html",content:""},{title:"",headers:[],path:"/tags/anzhuang/1.html",content:""},{title:"",headers:[],path:"/tags/gongjutuijian/1.html",content:""},{title:"",headers:[],path:"/tags/JDK/1.html",content:""},{title:"",headers:[],path:"/tags/IO/1.html",content:""},{title:"",headers:[],path:"/tags/zijieliu/1.html",content:""},{title:"",headers:[],path:"/tags/zifuliu/1.html",content:""},{title:"",headers:[],path:"/tags/huanchongliu/1.html",content:""},{title:"",headers:[],path:"/tags/NIO/1.html",content:""},{title:"",headers:[],path:"/tags/xuliehua/1.html",content:""},{title:"",headers:[],path:"/tags/fazhanjianshi/1.html",content:""},{title:"",headers:[],path:"/tags/lichengbeibanben/1.html",content:""},{title:"",headers:[],path:"/tags/shengtaiyanjin/1.html",content:""},{title:"",headers:[],path:"/tags/xianzaidequshi/1.html",content:""},{title:"",headers:[],path:"/tags/jianjie/1.html",content:""},{title:"",headers:[],path:"/tags/youlai/1.html",content:""},{title:"",headers:[],path:"/tags/shejilinian/1.html",content:""},{title:"",headers:[],path:"/tags/dangxiayiyi/1.html",content:""},{title:"",headers:[],path:"/tags/wangluobiancheng/1.html",content:""},{title:"",headers:[],path:"/tags/Java-xintexing/1.html",content:""},{title:"",headers:[],path:"/tags/mianxiangduixiang/1.html",content:""},{title:"",headers:[],path:"/tags/jichuyufa/1.html",content:""},{title:"",headers:[],path:"/tags/gongjulei/1.html",content:""},{title:"",headers:[],path:"/posts/1.html",content:""},{title:"",headers:[],path:"/posts/2.html",content:""},{title:"",headers:[],path:"/posts/3.html",content:""},{title:"Java项目中的防腐层介绍与实践",headers:["一、什么是防腐层？","二、为什么需要防腐层？","三、防腐层在 Java 项目中的位置","四、防腐层具体做什么？","1️⃣ 接口适配（翻译）","2️⃣ 隔离变化","3️⃣ 屏蔽技术细节","4️⃣ 保护与兜底","五、没有防腐层与有防腐层对比","没有防腐层（反例）","使用防腐层（推荐）","六、防腐层常见命名方式","七、什么时候一定要引入防腐层？","八、防腐层不是银弹","九、总结"],path:"/blogs/java/Javaxiangmuzhongdefangfucengjieshaoyushijian.html",content:'一、什么是防腐层？ 防腐层（Anti-Corruption Layer，简称 ACL ）并不是某个具体的框架或技术，而是一种 架构设计思想 ，最早来源于 领域设计驱动（DDD） 。 **具体解释：**将【自己系统】与【外部系统】之间加的”隔离和翻译层“，用于防止【外部系统】的设计问题污染自己的核心业务代码。唯一目的就是保证核心业务模型的纯净与稳定。 通俗理解： 可以把你的系统想象成一杯 干净的水 ，而外部系统是一条 水质不稳定的河流 。你不会直接把河水倒进杯子里，而是： 过滤 净化 再使用 这个“过滤器”，就是 防腐层 。 二、为什么需要防腐层？ 在真实的java项目中，我们经常需要对接： 对接老系统（历史包袱重） 第三方系统（不可控） 外部微服务（随时可变更） 这些系统通常存在以下问题： 字段命名混乱 数据结构不合理 接口定义不清晰 技术实现五花八门（HTTP / RPC / MQ / SOAP） 接口变更频繁 如果 业务代码直接依赖这些接口 ，会带来严重后果： 业务逻辑被迫适配外部设计 外部接口一改，内部大量代码跟着改 核心代码可读性、可维护性急剧下降 这正是防腐层要解决的问题。 三、防腐层在 Java 项目中的位置 一个典型的 Java 分层结构如下： Controller ↓ Application / Service ↓ Domain（核心业务模型） ↓ 【防腐层 ACL】 ↓ 外部系统 / 第三方系统 / 老系统 关键原则： 核心业务层 绝不 直接依赖外部系统 所有外部交互必须经过防腐层 四、防腐层具体做什么？ 1️⃣ 接口适配（翻译） 将外部系统的数据结构，转换为内部系统可理解的领域模型。 外部系统返回： { "usr_nm" : "zhangsan" , "age_flag" : "1" } 防腐层转换后： User { name = "zhangsan" ; isAdult = true ; } 2️⃣ 隔离变化 外部接口字段变更 返回结构调整 协议升级 👉 只修改防腐层，业务代码不动 。 3️⃣ 屏蔽技术细节 防腐层对上层暴露的是： 领域对象 领域语义的方法 而不是： HTTP / RPC 细节 JSON / XML 结构 超时、重试等技术细节 4️⃣ 保护与兜底 防腐层通常还会负责： 异常转换 超时处理 降级逻辑 默认值处理 防止外部系统不稳定直接影响核心业务。 五、没有防腐层与有防腐层对比 没有防腐层（反例） @Service public class OrderService { public void createOrder ( ) { ThirdResponse resp = thirdApi . query ( ) ; if ( "1" . equals ( resp . getFlag ( ) ) ) { // 业务逻辑 } } } 问题： 业务代码直接依赖第三方结构 可读性差 维护成本极高 使用防腐层（推荐） @Component public class UserAcl { public User getUser ( Long id ) { ThirdResponse resp = thirdApi . query ( id ) ; return UserTranslator . toUser ( resp ) ; } } @Service public class OrderService { public void createOrder ( ) { User user = userAcl . getUser ( 1L ) ; if ( user . isAdult ( ) ) { // 纯业务逻辑 } } } 优势： 业务语义清晰 外部变化可控 易测试、易维护 六、防腐层常见命名方式 在实际项目中，防腐层可能叫： xxxAcl xxxAdapter xxxFacade xxxClient xxxGateway 名字不重要， 职责才重要 。 七、什么时候一定要引入防腐层？ 强烈建议在以下场景使用： 对接第三方系统 对接老系统 微服务之间边界不清 项目生命周期较长 核心业务复杂 八、防腐层不是银弹 需要注意： 防腐层不是越多越好 内部模块之间不必强行加 ACL 简单系统可以适当简化 是否使用，取决于系统复杂度与演进预期。 九、总结 防腐层的本质，不是增加代码层级，而是为系统建立清晰边界。'},{title:"React消息队列优化实战",headers:["React 消息队列优化实战：从闭包陷阱到性能优化","前言","一、问题背景","二、React 核心知识点解析","2.1 闭包陷阱（Closure Trap）","2.2 useCallback：性能优化的利器","2.3 useMemo：缓存计算结果","2.4 useRef：跨越渲染的引用","2.5 Map 数据结构在 React 状态中的应用","三、自定义 Hook 设计模式","3.1 封装状态逻辑","3.2 返回稳定的 API","3.3 策略模式的应用","四、TypeScript 与 React 的结合","4.1 类型安全的 Hook","4.2 类型断言的使用","五、性能优化总结","5.1 优化清单","5.2 性能对比","六、最佳实践","6.1 Hook 使用原则","6.2 状态管理建议","七、总结","八、延伸阅读"],path:"/blogs/react/Reactxiaoxiduilieyouhuashizhan.html",content:"React 消息队列优化实战：从闭包陷阱到性能优化 前言 在 React 开发中，状态管理是一个永恒的话题。本文将通过一个真实的消息队列管理优化案例，深入探讨 React 中的几个核心概念： 闭包陷阱 、 函数式更新 、 性能优化 Hooks 以及 自定义 Hook 设计模式 。 一、问题背景 在实际项目中，我们遇到了一个消息队列管理的需求：需要管理多个消息弹窗，支持添加、删除、去重等功能。最初的实现使用数组存储消息： // ❌ 初始实现 const [ messageQueue , setMessageQueue ] = useState &lt; MessageParams [ ] > ( [ ] ) ; // 添加消息 setMessageQueue ( prev => [ ... prev , message ] ) ; // 删除消息（有问题！） cleanUp = { ( key ) => { setMessageQueue ( messageQueue . filter ( item => item . key !== key ) ) ; // 使用了闭包中的旧 messageQueue 值 } } 这个实现存在两个核心问题： 闭包陷阱 ：在事件处理函数中直接使用 messageQueue ，可能获取到过期的值 重复消息 ：数组结构无法有效去重，相同 key 的消息会重复显示 二、React 核心知识点解析 2.1 闭包陷阱（Closure Trap） 什么是闭包陷阱？ 闭包陷阱是 React 开发中最常见的坑之一。当我们在事件处理函数或异步回调中使用状态值时，如果直接引用状态变量，获取的可能是该函数创建时的旧值，而不是最新的状态值。 // ❌ 闭包陷阱示例 const [ count , setCount ] = useState ( 0 ) ; useEffect ( ( ) => { const timer = setInterval ( ( ) => { console . log ( count ) ; // 永远是 0！因为闭包捕获的是初始值 setCount ( count + 1 ) ; // 基于旧的 count 值 } , 1000 ) ; return ( ) => clearInterval ( timer ) ; } , [ ] ) ; // 空依赖数组，effect 只执行一次 解决方案：函数式更新（Functional Updates） React 的 setState 支持两种形式： 直接传入新值： setState(newValue) 传入更新函数： setState(prevState =&gt; newValue) 使用更新函数可以确保始终基于最新的状态值进行计算： // ✅ 正确方式：函数式更新 const removeMessage = useCallback ( ( key : string ) => { setMessageMap ( ( prevMap ) => { // prevMap 总是最新的状态值 const newMap = new Map ( prevMap ) ; newMap . delete ( key ) ; return newMap ; } ) ; } , [ ] ) ; // 不需要依赖 messageMap 关键要点： 函数式更新避免了对状态值的依赖 useCallback 的依赖数组可以为空，因为内部使用的是函数式更新 这种方式创建的闭包是稳定的，不会因为状态变化而失效 2.2 useCallback：性能优化的利器 为什么需要 useCallback？ 在 React 中，每次组件重新渲染时，函数都会重新创建。如果这个函数作为 prop 传递给子组件，会导致子组件不必要的重新渲染。 // ❌ 每次渲染都创建新函数 const handleClick = ( ) => { console . log ( 'clicked' ) ; } ; // 传递给子组件 &lt; ChildComponent onClick = { handleClick } / > // 子组件可能不必要地重新渲染 useCallback 的工作原理： useCallback 会返回一个记忆化的回调函数，只有当依赖项发生变化时，才会返回新的函数引用。 // ✅ 使用 useCallback const addMessage = useCallback ( ( message : MessageParams , options : AddMessageOptions = { strategy : MessageStrategy . REPLACE } ) => { setMessageMap ( ( prevMap ) => { // ... 更新逻辑 } ) ; } , [ mergeContent , generateUniqueKey ] ) ; // 依赖数组 依赖数组的优化： // ✅ 如果内部函数也使用了 useCallback，且没有依赖，可以省略依赖 const mergeContent = useCallback ( ( oldContent : React . ReactNode | string , newContent : React . ReactNode | string , separator : string = '\\n' ) : string => { // 纯函数，不依赖任何状态 return oldContent . trim ( ) + separator + newContent . trim ( ) ; } , [ ] ) ; // 空依赖数组 // addMessage 依赖 mergeContent，但 mergeContent 是稳定的 const addMessage = useCallback ( ( message , options ) => { // 使用 mergeContent } , [ mergeContent ] ) ; // mergeContent 引用稳定，addMessage 也稳定 最佳实践： 传递给子组件的函数使用 useCallback 包裹 依赖数组包含所有使用的值、函数和状态 如果函数是纯函数（不依赖外部状态），依赖数组可以为空 2.3 useMemo：缓存计算结果 何时使用 useMemo？ useMemo 用于缓存计算结果，避免不必要的重复计算。适用于： 计算开销较大的操作 派生状态的计算 需要过滤、转换的数组 // ❌ 每次渲染都重新计算 const visibleMessages = messageQueue . filter ( ( msg ) => { if ( typeof msg . content === 'string' ) { return msg . content . trim ( ) . length > 0 ; } return ! ! msg . content ; } ) ; // ✅ 使用 useMemo 缓存结果 const visibleMessages = useMemo ( ( ) => { return Array . from ( messageMap . values ( ) ) . filter ( ( msg ) => { if ( typeof msg . content === 'string' ) { return msg . content . trim ( ) . length > 0 ; } return ! ! msg . content ; } ) ; } , [ messageMap ] ) ; // 只有当 messageMap 变化时才重新计算 性能对比： // 假设 messageMap 有 100 条消息，过滤操作需要 1ms // ❌ 不使用 useMemo：每次渲染都执行（16ms @ 60fps） // 60 次渲染 = 60ms // ✅ 使用 useMemo：只有 messageMap 变化时执行 // 状态更新 5 次 = 5ms // 节省：55ms 使用建议： 不要过早优化，先衡量性能瓶颈 对于简单计算， useMemo 的开销可能大于收益 对于复杂计算和数组操作， useMemo 很有价值 2.4 useRef：跨越渲染的引用 useRef 的两大用途： 访问 DOM 元素 const inputRef = useRef &lt; HTMLInputElement > ( null ) ; &lt; input ref = { inputRef } / > ; 保存可变值（不触发重新渲染） 这是 useRef 的隐藏技能！可以保存任意可变值，更新它不会触发组件重新渲染。 // ✅ 用于存储计数器，不需要触发渲染 const uniqueKeyCounterRef = useRef &lt; Map &lt; string , number >> ( new Map ( ) ) ; const generateUniqueKey = useCallback ( ( baseKey : string ) : string => { const counter = uniqueKeyCounterRef . current . get ( baseKey ) || 0 ; const newCounter = counter + 1 ; // 直接修改 .current，不会触发重新渲染 uniqueKeyCounterRef . current . set ( baseKey , newCounter ) ; return ` ${ baseKey } - ${ Date . now ( ) } - ${ newCounter } ` ; } , [ ] ) ; // 没有依赖，函数引用永远稳定 为什么不用 useState？ // ❌ 如果用 useState，每次更新都会触发渲染 const [ counter , setCounter ] = useState ( 0 ) ; setCounter ( counter + 1 ) ; // 触发重新渲染，但组件可能不需要重新渲染 // ✅ 用 useRef，更新不触发渲染 const counterRef = useRef ( 0 ) ; counterRef . current = counterRef . current + 1 ; // 不触发渲染 使用场景： 存储定时器 ID 存储前一次渲染的值（用于比较） 存储不需要触发渲染的可变数据 在 useCallback / useMemo 的依赖中避免循环依赖 2.5 Map 数据结构在 React 状态中的应用 为什么选择 Map 而不是数组？ // ❌ 数组：查找 O(n)，删除需要遍历 const [ messages , setMessages ] = useState &lt; MessageParams [ ] > ( [ ] ) ; const hasMessage = messages . find ( msg => msg . key === key ) ; // O(n) // ✅ Map：查找 O(1)，删除直接 delete const [ messageMap , setMessageMap ] = useState &lt; Map &lt; string , MessageParams >> ( new Map ( ) ) ; const hasMessage = messageMap . has ( key ) ; // O(1) Map 的优势： 自动去重 ：key 唯一，相同 key 自动覆盖 高效查找 ：O(1) 时间复杂"},{title:"VuePress Theme Reco 扩展目录扫描功能实现",headers:["VuePress Theme Reco 扩展目录扫描功能实现","问题背景","问题分析","根本原因","尝试的方案","方案一：直接配置 catalogueInclude（失败）","方案二：扩展类型定义（不够）","最终解决方案","实现思路","代码实现","1. 创建自定义插件","2. 配置 TypeScript","3. 更新配置文件","4. 为 docs 文档添加 frontmatter","验证结果","控制台输出","生成的文件","访问地址","技术要点","1. VuePress 插件生命周期","2. 路径伪装技巧","3. TypeScript 类型处理","适用场景","注意事项","总结","参考资源"],path:"/blogs/qita/vuepress-theme-reco-catalogue-include.html",content:`VuePress Theme Reco 扩展目录扫描功能实现 问题背景 在使用 vuepress-theme-reco@2.0.0-rc.26 主题时，发现主题的标签（Tags）和分类（Categories）功能默认只扫描 blogs 目录下的文章，而 docs 目录下带有 tags 和 categories frontmatter 的文档无法被自动收集。 问题分析 根本原因 通过深入研究主题源码（ @vuepress-reco/vuepress-plugin-page 插件），发现主题在 PageCreater.js 中硬编码了只扫描 /blogs/ 目录的正则表达式： const blogsToBeReleased = this . app . pages . filter ( ( page ) => { const publishFlag = ! ( ! / .+\\/blogs\\/[(.+)\\/]?.+\\.md$ / . test ( page . filePath || '' ) || page ?. frontmatter ?. publish === false || page ?. title === '' ) ; // ... } ) 这个正则表达式 /.+\\/blogs\\/[(.+)\\/]?.+\\.md$/ 只会匹配 blogs 目录下的文件，导致其他目录的文档即使配置了 tags 和 categories 也不会被收集。 尝试的方案 方案一：直接配置 catalogueInclude （失败） 最初尝试在主题配置中添加 catalogueInclude 属性： theme : recoTheme ( { catalogueInclude : [ 'blogs' , 'docs' ] , // ❌ TypeScript 报错 // ... } ) 失败原因 ： RecoThemeData 类型中并不存在 catalogueInclude 属性。 方案二：扩展类型定义（不够） 创建类型声明文件扩展 RecoThemeData ： // .vuepress/types.d.ts import 'vuepress-theme-reco' declare module 'vuepress-theme-reco' { interface RecoThemeData { catalogueInclude ? : string [ ] } } 不足之处 ：虽然解决了类型问题，但主题内部逻辑仍然只扫描 blogs 目录。 最终解决方案 实现思路 创建一个自定义 VuePress 插件，通过&quot;路径伪装&quot;的方式欺骗主题的正则匹配： 识别目标文件 ：检测配置目录（如 docs ）下带有 tags 或 categories 的 Markdown 文件 路径伪装 ：临时将文件的 filePath 从 docs/xxx/yyy.md 改为 blogs/xxx/yyy.md 匹配正则 ：修改后的路径能够匹配主题的正则表达式 保留原路径 ：将原始目录信息保存在 frontmatter._originalDir 中，以便后续使用 代码实现 1. 创建自定义插件 创建文件 .vuepress/plugin-blog-page-filter.ts ： import type { Plugin } from 'vuepress' import type { Page } from '@vuepress/core' export interface BlogPagePluginOptions { /** * 需要扫描的目录列表 */ catalogueInclude ? : string [ ] } export const blogPagePlugin = ( options : BlogPagePluginOptions = { } ) : Plugin => { const { catalogueInclude = [ 'blogs' ] } = options return { name : '@local/vuepress-plugin-blog-page-filter' , extendsPage : ( page : Page ) => { // vuepress-theme-reco 硬编码了只扫描 /blogs/ 目录的正则: /.+\\/blogs\\/[(.+)\\/]?.+\\.md$/ // 我们需要修改 filePath 让其他目录的文件也能被识别为博客文章 if ( ! page . filePath ) return // 检查页面是否在配置的目录中(但不在 blogs 目录) const isInOtherCatalogue = catalogueInclude . some ( dir => { if ( dir === 'blogs' ) return false // 跳过 blogs,它已经被主题支持 return page . filePathRelative ?. startsWith ( \` \${ dir } / \` ) } ) // 如果页面在其他目录中，且有 tags 或 categories，修改其 filePath if ( isInOtherCatalogue &amp;&amp; ( page . frontmatter ?. tags || page . frontmatter ?. categories ) ) { // 将 docs/xxx/yyy.md 的路径模式改为 blogs/xxx/yyy.md 的模式 // 这样就能匹配主题的正则表达式 const match = page . filePathRelative ?. match ( / ^([^/]+)\\/(.+)$ / ) if ( match ) { const [ , dir , restPath ] = match // 保存原始路径到 frontmatter，以便后续使用 page . frontmatter . _originalDir = dir // 临时修改 filePath 以匹配主题的正则 page . filePath = page . filePath . replace ( new RegExp ( \` / \${ dir } / \` ) , '/blogs/' ) console . log ( \` [Blog Page Filter] 修改路径: \${ page . filePathRelative } -> 伪装为 blogs 目录 \` ) } } } , } } 2. 配置 TypeScript 创建 tsconfig.json （如果不存在）： { "compilerOptions" : { "target" : "ES2020" , "module" : "ESNext" , "moduleResolution" : "node" , "strict" : false , "jsx" : "preserve" , "esModuleInterop" : true , "skipLibCheck" : true , "forceConsistentCasingInFileNames" : true , "resolveJsonModule" : true , "types" : [ "node" ] } , "include" : [ ".vuepress/**/*.ts" , ".vuepress/**/*.d.ts" , ".vuepress/**/*.vue" ] , "exclude" : [ "node_modules" , ".vuepress/.temp" , ".vuepress/.cache" , ".vuepress/dist" ] } 3. 更新配置文件 修改 .vuepress/config.ts ： import { defineUserConfig } from "vuepress" ; import recoTheme from "vuepress-theme-reco" ; import { viteBundler } from '@vuepress/bundler-vite' import { blogPagePlugin } from './plugin-blog-page-filter' export default defineUserConfig ( { title : "vuepress-theme-reco" , description : "Just playing around" , bundler : viteBundler ( ) , // 添加自定义插件 plugins : [ blogPagePlugin ( { catalogueInclude : [ 'blogs' , 'docs' ] // 配置需要扫描的目录 } ) ] , theme : recoTheme ( { logo : "/logo.png" , author : "reco_luan" , // ... 其他配置 } ) , } ) ; 4. 为 docs 文档添加 frontmatter 确保 docs 目录下的文档包含 tags 和 categories： --- title : API 文档 date : 2020/05/29 tags : - api - docs categories : - documentation --- 这是 API 文档内容... 验证结果 控制台输出 启动开发服务器后，可以看到插件正在工作： [ Blog Page Filter ] 修改路径: docs/theme-reco/plugin.md - > 伪装为 blogs 目录 [ Blog Page Filter ] 修改路径: docs/theme-reco/api.md - > 伪装为 blogs 目录 [ Blog Page Filter ] 修改路径: docs/theme-reco/home.md - > 伪装为 blogs 目录 [ Blog Page Filter ] 修改路径: docs/theme-reco/theme.md - > 伪装为 blogs 目录 生成的文件 在 .vuepress/.temp/pages/ 目录下成功生成了： 标签页面 ： tags/docs/1.html.js - &quot;docs&quot; 标签 tags/api/1.html.js - &quot;api&quot; 标签 tags/plugin/1.html.js - &quot;plugin&quot; 标签 tags/theme/1.html.js - &quot;theme&quot; 标签 tags/home/1.html.js - &quot;home&quot; 标签 分类页面 ： categories/documentation/1.html.js - &quot;documentation&quot; 分类 访问地址 启动开发服务器后，可以访问： 标签页： http://localhost:8080/tags/docs/1.html 分类页： http://localhost:8080/categories/documentation/1.html 技术要点 1. VuePress 插件生命周期 使用 extendsPage hook 在页面创建时修改页面属性，这个时机刚好在主题的 @vuepress-reco/vuepress-plugin-page 插件处理之前。 2. 路径伪装技巧 通过修改 page.filePath 而不是 page.filePathRelative ，确保： 主题的正则匹配能够通过 页面`},{title:"使用git做项目管理（初学版）",headers:["使用 Git 做项目管理（初学版）","一、什么是 Git？为什么要用它？","二、使用 Git 做项目管理","1. 创建项目","2. 添加文件","3. 提交文件","三、查看项目历史","四、用 Git 管理“项目进度”","1. 一个任务 = 一次提交","2. 提交信息建议","五、使用分支（简单理解）","1. 什么是分支？","2. 合并分支","六、项目里程碑（可选）","七、初学者常见错误","八、总结"],path:"/docs/git/shiyonggitzuoxiangmuguanli（chuxueban）.html",content:'使用 Git 做项目管理（初学版） 很多人第一次接触 Git，只把它当作“代码备份工具”。 其实，Git 更重要的作用是： 帮助我们把项目过程管理清楚 。 这篇文章将从零开始，教你如何使用 Git 来管理一个项目。 一、什么是 Git？为什么要用它？ Git 是一个 版本控制工具 ，可以帮你解决以下问题： 文件改乱了，想回到昨天的状态 多个人同时做一个项目，文件互相覆盖 不知道“这个改动是谁什么时候做的” 📌 一句话理解 Git： Git 是项目的“时间记录器” 二、使用 Git 做项目管理 1. 创建项目 首先，新建一个项目文件夹，并初始化 Git 仓库。 mkdir my-project cd my-project git init 这一步表示： 创建了一个项目 Git 开始管理这个项目 执行成功后，项目目录中会出现一个 .git 文件夹。 2. 添加文件 在项目中创建一个项目说明文件： touch README.md 在 README.md 中写入： # 我的第一个 Git 项目 这是一个用于学习 Git 项目管理的示例项目。 然后把文件交给 Git 管理： git add README.md 📌 小知识： git add 不是提交 它只是告诉 Git： 这些文件我准备好了 3. 提交文件 将已添加的文件正式保存到 Git 仓库中： git commit -m "初始化项目说明文档" 一次提交（commit）代表： 项目的一次进展 一个可以回到的历史节点 📌 好习惯： 写清楚提交信息 不要用“修改”“更新”这种模糊描述 三、查看项目历史 可以查看项目的修改记录： git log 简洁查看： git log --oneline 你会看到： 做了什么修改 谁做的 什么时候做的 四、用 Git 管理“项目进度” 1. 一个任务 = 一次提交 示例： 写完项目介绍 → 提交 完成一个功能 → 提交 修改一个 Bug → 提交 git commit -m "完成用户登录页面" 这样可以清楚看到项目进度。 2. 提交信息建议 初学者可以用最简单的格式： 做了什么 例如： 完成实验报告第一部分 增加课程设计说明 修复页面显示问题 五、使用分支（简单理解） 1. 什么是分支？ 分支就像： 在不影响主作业的情况下，先写草稿 主分支一般叫 main 。 创建一个新分支： git checkout -b homework 在分支上修改、提交，不会影响主分支。 2. 合并分支 完成后，把分支合并回主分支： git checkout main git merge homework 📌 对学生来说： 分支可以用来写实验、作业、功能草稿 不用担心改坏主版本 六、项目里程碑（可选） 当项目完成一个阶段，可以打一个标签： git tag v1.0 例如： 实验一完成 课程设计初版完成 七、初学者常见错误 ❌ 很久才提交一次 ❌ 提交信息太随意 ❌ 所有修改都放在一个提交里 ❌ 忘记先 git add 八、总结 Git = 学习过程的记录工具 学会用 Git 管理项目，你将： 不再害怕改错 清楚自己的学习进度 为以后进入团队开发打好基础'},{title:"使用git做项目管理（团队版）",headers:["Git 项目管理规范（团队版）","1. 文档目的","2. 仓库初始化规范","2.1 项目初始化","2.2 推荐目录结构","3. 分支管理规范","3.1 分支说明","3.2 分支使用规则","4. 提交（Commit）规范","4.1 基本原则","4.2 提交信息格式","4.3 Type 说明","5. 代码合并规范","5.1 合并前要求","5.2 合并方式","6. Tag 与版本管理","6.1 版本命名规范","6.2 打标签流程","7. 多人协作流程","8. 常见禁止行为","9. 项目管理建议","10. 总结"],path:"/docs/git/shiyonggitzuoxiangmuguanli（tuanduiban）.html",content:"Git 项目管理规范（团队版） 1. 文档目的 本规范用于统一团队在项目中使用 Git 的方式，确保： 项目过程清晰可追溯 多人协作高效、可控 降低冲突和回滚成本 形成长期可复用的协作规范 2. 仓库初始化规范 2.1 项目初始化 每个项目必须创建独立 Git 仓库： git init 项目创建后 第一件事必须提交基础结构 。 2.2 推荐目录结构 project/ ├── docs/ # 项目文档 ├── src/ # 源代码 ├── tests/ # 测试 ├── .gitignore └── README.md 📌 规范要求： 文档与代码统一纳入 Git 管理 不允许直接在仓库中提交临时文件、构建产物 3. 分支管理规范 3.1 分支说明 分支名 用途 main 稳定可发布版本 develop 日常开发集成分支 feature/* 功能开发分支 hotfix/* 紧急修复分支 3.2 分支使用规则 ❌ 禁止直接在 main 分支开发 所有功能开发必须从 develop 创建分支 功能完成后合并回 develop 版本发布时由 develop 合并到 main git checkout -b feature/login develop 4. 提交（Commit）规范 4.1 基本原则 一个提交只做一件事 提交必须可回滚 提交信息必须可读、可理解 4.2 提交信息格式 统一使用以下格式： &lt;type>(&lt;scope>): &lt;description> 示例： feat(login): 实现用户登录功能 fix(order): 修复订单金额计算错误 docs(readme): 更新项目说明 4.3 Type 说明 Type 含义 feat 新功能 fix 修复缺陷 docs 文档 refactor 重构 test 测试 chore 杂项 5. 代码合并规范 5.1 合并前要求 合并到 develop 或 main 前，必须： 本地代码可正常运行 已拉取最新代码 冲突已解决 git pull --rebase origin develop 5.2 合并方式 功能分支 → develop ： merge 发布 → main ： merge 禁止强制 push 到公共分支 6. Tag 与版本管理 6.1 版本命名规范 v主版本.次版本.修订号 示例： v1.0.0 v1.1.0 v1.1.1 6.2 打标签流程 git tag v1.0.0 git push origin v1.0.0 📌 Tag 只允许打在 main 分支。 7. 多人协作流程 1. 从 develop 创建功能分支 2. 本地开发并频繁提交 3. 拉取最新 develop 4. 解决冲突 5. 提交合并请求 6. Code Review 7. 合并到 develop 8. 常见禁止行为 ❌ 直接修改 main 分支 ❌ 提交无意义的 commit 信息 ❌ 一个 commit 包含多个不相关修改 ❌ 强制覆盖他人提交 9. 项目管理建议 每个功能 / 需求对应一个分支 每次提交代表一个“项目进展点” 通过 Git 历史回顾项目决策过程 定期清理无用分支 10. 总结 统一规范比个人习惯更重要 通过规范化使用 Git： 项目更稳定 协作更高效 责任更清晰 风险可控"},{title:"2.3 数组与字符串",headers:["数组与字符串","数组","常见操作","字符串","常用方法","注意"],path:"/docs/javajichu/array-string.html",content:'数组与字符串 数组 int [ ] scores = { 98 , 87 , 92 } ; scores [ 1 ] = 90 ; System . out . println ( scores . length ) ; 常见操作 遍历：for / foreach 排序： Arrays.sort(scores) 拷贝： Arrays.copyOf(scores, scores.length) 字符串 String name = "Java" ; String welcome = "Hello " + name ; 常用方法 length() ：长度 substring(begin, end) ：子串 equals() ：内容比较 split() ：拆分 StringBuilder ：高频拼接 StringBuilder builder = new StringBuilder ( ) ; builder . append ( "Hello" ) ; builder . append ( " Java" ) ; System . out . println ( builder . toString ( ) ) ; 注意 字符串不可变，每次修改都会生成新对象。 当需要频繁拼接时请选择 StringBuilder . Arrays 默认 toString 不友好，可使用 Arrays.toString .'},{title:"小册简介",headers:["小册简介","学习路径","阅读建议"],path:"/docs/javajichu/booklet.html",content:"小册简介 本章节给出整个 Java 学习小册的全貌，帮助你弄清楚“为什么学、学什么、怎么学”。 学习路径 前言 ：了解 Java 的诞生与发展。 环境搭建 ：安装 JDK、IDEA，熟悉命令行工具。 语法基础 ：变量、流程控制、方法。 核心能力 ：面向对象、集合、异常、IO。 进阶模块 ：并发、网络、常用工具、新特性。 阅读建议 左侧目录按照章节递进，可作为线性课程。 每篇文章末尾会给出练习和延伸阅读。 配合官方文档与开源项目，才能真正掌握。"},{title:"2.5 集合框架（含容器）",headers:["集合框架（含容器）","体系图","List 示例","Set 示例","Map 示例","迭代方式","使用建议"],path:"/docs/javajichu/collections.html",content:'集合框架（含容器） 体系图 Collection List : ArrayList, LinkedList Set : HashSet, TreeSet Map : HashMap, LinkedHashMap, TreeMap List 示例 List &lt; String > names = new ArrayList &lt; > ( ) ; names . add ( "Java" ) ; names . add ( "Kotlin" ) ; System . out . println ( names . get ( 0 ) ) ; Set 示例 Set &lt; Integer > ids = new HashSet &lt; > ( ) ; ids . add ( 1 ) ; ids . add ( 1 ) ; // 自动去重 System . out . println ( ids . size ( ) ) ; // 1 Map 示例 Map &lt; String , Integer > score = new HashMap &lt; > ( ) ; score . put ( "张三" , 95 ) ; score . put ( "李四" , 88 ) ; System . out . println ( score . get ( "张三" ) ) ; 迭代方式 for-each Iterator Java 8 forEach names . forEach ( System . out :: println ) ; 使用建议 根据访问/插入场景选择 ArrayList 或 LinkedList 需要线程安全可使用 Collections.synchronizedList 或 CopyOnWriteArrayList 使用 Objects.equals 和 Objects.hash 实现 equals/hashCode'},{title:"2.7 异常处理",headers:["异常处理","异常分类","try-catch-finally","自定义异常","最佳实践"],path:"/docs/javajichu/exception.html",content:'异常处理 异常分类 受检异常 （checked）：编译器要求显式处理，例如 IOException . 运行时异常 （runtime）： NullPointerException 、 IllegalArgumentException . 错误 （Error）： OutOfMemoryError 等，通常无法恢复。 try-catch-finally try { Files . readString ( Path . of ( "config.json" ) ) ; } catch ( IOException e ) { log . error ( "读取配置失败" , e ) ; } finally { System . out . println ( "一定会执行" ) ; } 自定义异常 public class BizException extends RuntimeException { public BizException ( String message ) { super ( message ) ; } } 最佳实践 优先抛出有意义的自定义异常，便于定位问题。 不要在 catch 中吞掉异常。 使用日志记录上下文信息。 善用 try-with-resources 自动关闭资源。'},{title:"第一个 Java 程序",headers:["第一个 Java 程序","使用命令行","在 IntelliJ IDEA 中运行","拓展练习"],path:"/docs/javajichu/hello-world.html",content:'第一个 Java 程序 使用命令行 HelloWorld.java public class HelloWorld { public static void main ( String [ ] args ) { System . out . println ( "Hello Java!" ) ; } } javac HelloWorld.java java HelloWorld 在 IntelliJ IDEA 中运行 新建 Class，粘贴上述代码。 点击左侧绿色运行按钮。 在 Run 控制台看到输出。 拓展练习 修改输出内容为自己的名字。 使用 Scanner 读取输入。 尝试将代码打包为 .jar 并运行： jar --create --file hello.jar HelloWorld.class .'},{title:"安装 IntelliJ IDEA",headers:["安装 IntelliJ IDEA","版本选择","安装步骤","常用配置","必备插件","第一个项目"],path:"/docs/javajichu/install-idea.html",content:"安装 IntelliJ IDEA 版本选择 Community ：免费开源，足够完成 Java SE | Spring Boot 学习。 Ultimate ：付费版，提供更丰富的企业级框架支持。 安装步骤 访问 JetBrains 官网下载对应平台的安装包。 安装完成后首次启动，会提示导入设置或使用默认配置。 配置 JDK： File -&gt; Project Structure -&gt; SDKs -&gt; Add . 在 File -&gt; New -&gt; Project 处创建第一个 Java 项目。 常用配置 主题 ： Settings -&gt; Appearance -&gt; Theme ，可选择 Darcula 或自定义主题。 快捷键 ： Keymap 中可选择 VS Code / Eclipse 习惯。 自动保存 ：开启 Save files if the IDE is idle for x seconds 。 必备插件 Key Promoter X ：学习快捷键。 Alibaba Java Coding Guidelines ：遵循阿里 Java 规范。 Rainbow Brackets ：彩虹括号，提升可读性。 第一个项目 新建 HelloWorld 项目。 右键 src -&gt; New -&gt; Java Class -&gt; HelloWorld 。 输入示例代码并运行，确保环境可用。"},{title:"安装 JDK",headers:["安装 JDK","选择版本","Windows 安装","macOS 安装","Linux 安装","验证"],path:"/docs/javajichu/install-jdk.html",content:"安装 JDK 选择版本 学习阶段推荐使用长期支持版本（LTS），如 Java 17 或 Java 21。 Oracle、Adoptium、Amazon Corretto 等发行版均可，保持版本一致最重要。 Windows 安装 前往发行版官网下载安装包。 双击安装，建议把路径设置为 C:\\\\Java\\\\jdk-17 这类不含空格的目录。 配置环境变量： JAVA_HOME = C:\\\\Java\\\\jdk-17 在 Path 中新增 %JAVA_HOME%\\\\bin 打开 PowerShell 执行 java -version 验证。 macOS 安装 brew install temurin java -version Linux 安装 sudo apt install temurin-17-jdk java -version 验证 java -version javac -version 若输出版本号即安装成功。"},{title:"2.6 Java IO",headers:["Java IO","字节流与字符流","缓冲流","NIO","序列化","注意事项"],path:"/docs/javajichu/io.html",content:'Java IO 字节流与字符流 字节流： InputStream / OutputStream 字符流： Reader / Writer try ( FileInputStream in = new FileInputStream ( "demo.txt" ) ; FileOutputStream out = new FileOutputStream ( "copy.txt" ) ) { byte [ ] buffer = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } } 缓冲流 try ( BufferedReader reader = Files . newBufferedReader ( Path . of ( "demo.txt" ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { System . out . println ( line ) ; } } NIO Files 、 Paths 提供更易用的 API ByteBuffer 、 Channels 支持更高性能的操作 序列化 try ( ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( "user.bin" ) ) ) { oos . writeObject ( new User ( "Java" , 28 ) ) ; } 注意事项 及时关闭流，优先使用 try-with-resources 善用 Files.copy 、 Files.readAllLines 等工具方法 大文件传输可考虑 NIO 或 Netty'},{title:"Java 发展简史",headers:["Java 发展简史","里程碑版本","生态演进","现在的趋势"],path:"/docs/javajichu/java-history.html",content:"Java 发展简史 里程碑版本 Java 1.0（1995） ：面向互联网的第一版，实现了 Applet、AWT 等基础能力。 Java 5（2004） ：引入泛型、注解、枚举、自动装箱，极大提升了表达力。 Java 8（2014） ：Lambda、Stream、CompletableFuture 成为现代 Java 的分水岭。 Java 9+（2017 起） ：模块化系统（Jigsaw）和半年一更的发布节奏。 生态演进 框架 ：Spring、Spring Boot、Spring Cloud 逐步成为事实标准。 服务器端技术 ：Servlet/JSP → MVC → 微服务/Serverless。 构建工具 ：Ant → Maven → Gradle。 部署形态 ：传统应用服务器 → 容器化 → 云原生。 现在的趋势 长期支持（LTS）版本依旧是企业主力（如 Java 17/21）。 对开发体验关注度提升，Record、Pattern Matching 等语法陆续落地。 GraalVM、本地镜像（Native Image）让 Java 的启动和内存表现更上一层楼。"},{title:"Java 简介",headers:["Java 简介","Java 是什么？","核心组成","与其他语言的关系","什么时候选用 Java？"],path:"/docs/javajichu/java-intro.html",content:"Java 简介 Java 是什么？ Java 是一门面向对象的通用型编程语言，依托 JVM 可以运行在 Windows、Linux、macOS 等多种平台上。其语法吸收了 C/C++ 的设计，同时通过自动内存管理让开发体验更加安全。 核心组成 语言本身 ：语法、关键字、类库。 JVM（Java Virtual Machine） ：字节码执行引擎。 JDK（Java Development Kit） ：开发者工具集，包含编译器、调试器等。 JRE（Java Runtime Environment） ：运行时环境，供线上运行使用。 与其他语言的关系 与 C++ ：语法类似，但 Java 没有指针和多继承，GC 更友好。 与 Python ：Python 语法更简洁，但 Java 在类型系统、性能和生态方面更适合大型项目。 与 Kotlin ：Kotlin 在 JVM 上运行，语法更现代，可与 Java 互操作。 什么时候选用 Java？ 需要稳定、高吞吐的企业级服务。 团队规模较大，需要成熟的工程化体系。 对跨平台部署有要求。 需要长期维护的业务系统。"},{title:"Java 由来",headers:["Java 由来","设计理念","当下意义"],path:"/docs/javajichu/java-origin.html",content:"Java 由来 Java 最早是 Sun 公司在 1990 年代为嵌入式设备准备的一门语言，项目代号 Oak 。随着互联网浪潮爆发，团队意识到“跨平台”才是更具潜力的方向，于是在 1995 年将其正式命名为 Java，并在 Netscape 浏览器中以 Applet 形式亮相。 设计理念 一次编写，到处运行 ：借助 JVM 屏蔽操作系统差异。 安全 ：通过字节码校验、类加载器和安全管理器构建沙箱。 简洁 ：去掉了 C/C++ 中复杂的指针和多继承语法。 当下意义 虽然 Applet 早已成为历史，但 Java“跨平台 + 稳定可靠”的 DNA 被保留下来，广泛应用于企业级后端、大数据、移动端乃至云原生场景。"},{title:"2.10 网络编程",headers:["网络编程","Socket 基础","HTTP 客户端","Netty 与 Reactor","调试技巧"],path:"/docs/javajichu/networking.html",content:'网络编程 Socket 基础 // 服务端 try ( ServerSocket server = new ServerSocket ( 8000 ) ) { while ( true ) { Socket socket = server . accept ( ) ; handle ( socket ) ; } } // 客户端 try ( Socket socket = new Socket ( "localhost" , 8000 ) ; PrintWriter out = new PrintWriter ( socket . getOutputStream ( ) , true ) ) { out . println ( "Hello Server" ) ; } HTTP 客户端 HttpClient client = HttpClient . newHttpClient ( ) ; HttpRequest request = HttpRequest . newBuilder ( ) . uri ( URI . create ( "https://api.example.com" ) ) . GET ( ) . build ( ) ; HttpResponse &lt; String > response = client . send ( request , BodyHandlers . ofString ( ) ) ; System . out . println ( response . body ( ) ) ; Netty 与 Reactor Netty 提供高性能异步网络框架，适合自定义协议。 Spring WebFlux 基于 Reactor，面向响应式编程。 调试技巧 使用 tcpdump / Wireshark 抓包。 善用 nc 、 curl 等命令行工具模拟请求。 关注超时、重试、连接池配置。'},{title:"2.9 Java 新特性",headers:["Java 新特性","Java 8","Java 11","Java 17","Java 21（LTS）","升级建议"],path:"/docs/javajichu/new-features.html",content:'Java 新特性 Java 8 Lambda 表达式 Stream API Optional CompletableFuture List &lt; String > result = names . stream ( ) . filter ( name -> name . startsWith ( "J" ) ) . map ( String :: toUpperCase ) . toList ( ) ; Java 11 var 本地变量类型推断 HttpClient 新 API 字符串增强： &quot;demo&quot;.isBlank() Java 17 sealed class record Pattern Matching for instanceof record User ( String name , int age ) { } if ( obj instanceof User user ) { System . out . println ( user . name ( ) ) ; } Java 21（LTS） 虚拟线程（Virtual Threads） 模式匹配 switch Structured Concurrency（预览） 升级建议 生产环境尽量使用 LTS 版本。 每年关注一次 JEP 列表，了解未来方向。 通过 Maven/Gradle 的 targetCompatibility 控制编译目标，保证兼容性。'},{title:"2.4 面向对象编程",headers:["面向对象编程","类与对象","封装","继承","多态","接口与抽象类","实践建议"],path:"/docs/javajichu/oop.html",content:`面向对象编程 类与对象 public class User { private String name ; private int age ; public User ( String name , int age ) { this . name = name ; this . age = age ; } public void sayHello ( ) { System . out . println ( "Hi, I'm " + name ) ; } } 封装 使用 private 隐藏内部数据 提供 getter/setter 继承 public class Employee extends User { private String title ; public Employee ( String name , int age , String title ) { super ( name , age ) ; this . title = title ; } } 多态 User user = new Employee ( "Alice" , 26 , "SE" ) ; user . sayHello ( ) ; // 调用子类实现 接口与抽象类 接口：约定行为，多实现 抽象类：部分实现，可包含状态 实践建议 遵循单一职责原则 组合优于继承 使用 Lombok 或 Record 简化数据类`},{title:"2.2 Java 语法基础",headers:["Java 语法基础","数据类型","流程控制","方法","包与访问控制","建议"],path:"/docs/javajichu/syntax.html",content:`Java 语法基础 数据类型 基本类型 ： byte , short , int , long , float , double , char , boolean 引用类型 ：类、接口、数组、枚举 int age = 18 ; double price = 19.99 ; boolean vip = true ; char level = 'A' ; 流程控制 if ( score >= 90 ) { System . out . println ( "优秀" ) ; } else if ( score >= 60 ) { System . out . println ( "及格" ) ; } else { System . out . println ( "加油" ) ; } for ( int i = 0 ; i &lt; 5 ; i ++ ) { System . out . println ( i ) ; } 方法 public static int add ( int a , int b ) { return a + b ; } 包与访问控制 public ：对所有类可见 protected ：同包或子类可见 default ：仅同包可见 private ：仅当前类可见 建议 使用驼峰命名 一个文件只放一个 public 类 合理拆分方法，方法不要太长`},{title:"2.8 常用工具类",headers:["常用工具类","Objects","Math 与 BigDecimal","Collections","Optional","日期时间","Apache Commons / Hutool","建议"],path:"/docs/javajichu/tools.html",content:'常用工具类 Objects Objects . equals ( a , b ) ; Objects . requireNonNull ( param , "参数不能为空" ) ; Math 与 BigDecimal double result = Math . pow ( 2 , 10 ) ; BigDecimal price = new BigDecimal ( "19.99" ) ; price = price . multiply ( new BigDecimal ( "0.85" ) ) ; Collections List &lt; String > unmodifiable = Collections . unmodifiableList ( names ) ; Collections . shuffle ( list ) ; Collections . sort ( list ) ; Optional Optional . ofNullable ( user ) . map ( User :: getEmail ) . ifPresent ( System . out :: println ) ; 日期时间 LocalDate today = LocalDate . now ( ) ; LocalDateTime deadline = LocalDateTime . now ( ) . plusDays ( 3 ) ; DateTimeFormatter fmt = DateTimeFormatter . ofPattern ( "yyyy-MM-dd HH:mm:ss" ) ; System . out . println ( deadline . format ( fmt ) ) ; Apache Commons / Hutool StringUtils , FileUtils , DigestUtils Hutool 提供 Http、Excel、Cache 等实用工具 建议 封装自己的工具类时注意通用性与复用。 不要为了“方便”滥用静态方法，保持职责单一。'},{title:"Java 自学系列",headers:["Java 自学系列 ☕","📚 系列简介","🗺️ 学习路线图","📖 章节目录","🔰 第一阶段:Java 基础","01. Java 入门","02. 基础语法","03. 面向对象编程","04. 核心 API","🚀 第二阶段:进阶核心","05. 集合框架","06. 泛型编程","07. 多线程与并发","08. JVM 工作原理","09. Java 8 新特性","🎯 第三阶段:框架与实战","10. Spring 全家桶","11. 数据库与持久化","12. 项目实战","🎓 学习建议","💪 适合人群","📝 更新日志"],path:"/series/java/",content:"Java 自学系列 ☕ 📚 系列简介 这是一个从零到进阶的 Java 完整学习路线 ,适合自学者系统掌握 Java 开发技能。 本系列特点: ✅ 从零开始,无需任何基础 ✅ 循序渐进,难度逐步升级 ✅ 理论结合实战 ✅ 完整覆盖 Java 核心知识体系 ✅ 包含 Spring 全家桶与项目实战 🗺️ 学习路线图 入门基础 → 面向对象 → 核心 API → 集合框架 → 泛型 ↓ 多线程 → JVM 原理 → Java 8 新特性 ↓ Spring 生态 → 数据库持久化 → 项目实战 📖 章节目录 🔰 第一阶段:Java 基础 01. Java 入门 什么是 Java Java 平台体系 开发环境搭建 02. 基础语法 变量与常量 数据类型 运算符 流程控制 方法定义与调用 03. 面向对象编程 面向对象核心概念 类与对象 继承 多态 接口 抽象类 04. 核心 API String 字符串 包装类型 异常处理 文件 I/O 操作 注解 🚀 第二阶段:进阶核心 05. 集合框架 集合框架概述 List 列表 Set 集合 Map 映射 集合工具类与算法 06. 泛型编程 为什么需要泛型 泛型方法与通配符 07. 多线程与并发 线程基础 Runnable 与 Callable 线程安全 synchronized 关键字 Lock 锁机制 线程池 08. JVM 工作原理 JVM 体系结构 类加载机制 内存结构 垃圾回收机制 JVM 调优 09. Java 8 新特性 Lambda 表达式 Stream API 新日期时间 API 🎯 第三阶段:框架与实战 10. Spring 全家桶 Spring IoC 容器 Spring AOP 面向切面编程 Spring Boot 入门 Spring MVC 原理 11. 数据库与持久化 JDBC 数据库连接 MyBatis 持久层框架 Spring Data JPA 12. 项目实战 项目环境准备 后端 API 设计 Spring Boot 项目实战 项目部署上线 🎓 学习建议 按顺序学习 :章节之间有递进关系,建议按照顺序学习 动手实践 :每个知识点都要动手写代码验证 做好笔记 :记录重点和疑问,定期复习 坚持刷题 :配合 LeetCode 等平台巩固基础 实战项目 :学完理论后一定要完成至少一个完整项目 💪 适合人群 ✅ 零基础编程初学者 ✅ 想转行做 Java 开发的朋友 ✅ 需要系统梳理 Java 知识体系的开发者 ✅ 准备求职面试的应届生 📝 更新日志 2025-01-01 : 创建 Java 自学系列完整目录结构 🚀 开始你的 Java 学习之旅吧! 坚持学习,持续进步 💪"},{title:"什么是 Java",headers:["什么是 Java"],path:"/series/java/01-introduction/01-what-is-java.html",content:"什么是 Java"},{title:"Java 平台体系",headers:["Java 平台体系"],path:"/series/java/01-introduction/02-java-platforms.html",content:"Java 平台体系"},{title:"开发环境搭建",headers:["开发环境搭建"],path:"/series/java/01-introduction/03-environment-setup.html",content:"开发环境搭建"},{title:"变量与常量",headers:["变量与常量"],path:"/series/java/02-basic-syntax/01-variables.html",content:"变量与常量"},{title:"数据类型",headers:["数据类型"],path:"/series/java/02-basic-syntax/02-data-types.html",content:"数据类型"},{title:"运算符",headers:["运算符"],path:"/series/java/02-basic-syntax/03-operators.html",content:"运算符"},{title:"流程控制",headers:["流程控制"],path:"/series/java/02-basic-syntax/04-control-flow.html",content:"流程控制"},{title:"方法定义与调用",headers:["方法定义与调用"],path:"/series/java/02-basic-syntax/05-methods.html",content:"方法定义与调用"},{title:"面向对象核心概念",headers:["面向对象核心概念"],path:"/series/java/03-object-oriented/01-oop-concepts.html",content:"面向对象核心概念"},{title:"类与对象",headers:["类与对象"],path:"/series/java/03-object-oriented/02-classes-and-objects.html",content:"类与对象"},{title:"继承",headers:["继承"],path:"/series/java/03-object-oriented/03-inheritance.html",content:"继承"},{title:"多态",headers:["多态"],path:"/series/java/03-object-oriented/04-polymorphism.html",content:"多态"},{title:"接口",headers:["接口"],path:"/series/java/03-object-oriented/05-interfaces.html",content:"接口"},{title:"抽象类",headers:["抽象类"],path:"/series/java/03-object-oriented/06-abstract-classes.html",content:"抽象类"},{title:"String 字符串",headers:["String 字符串"],path:"/series/java/04-core-api/01-string.html",content:"String 字符串"},{title:"包装类型",headers:["包装类型"],path:"/series/java/04-core-api/02-wrapper-types.html",content:"包装类型"},{title:"异常处理",headers:["异常处理"],path:"/series/java/04-core-api/03-exceptions.html",content:"异常处理"},{title:"文件 I/O 操作",headers:["文件 I/O 操作"],path:"/series/java/04-core-api/04-file-io.html",content:"文件 I/O 操作"},{title:"注解",headers:["注解"],path:"/series/java/04-core-api/05-annotations.html",content:"注解"},{title:"集合框架概述",headers:["集合框架概述"],path:"/series/java/05-collections/01-collection-overview.html",content:"集合框架概述"},{title:"List 列表",headers:["List 列表"],path:"/series/java/05-collections/02-list.html",content:"List 列表"},{title:"Set 集合",headers:["Set 集合"],path:"/series/java/05-collections/03-set.html",content:"Set 集合"},{title:"Map 映射",headers:["Map 映射"],path:"/series/java/05-collections/04-map.html",content:"Map 映射"},{title:"集合工具类与算法",headers:["集合工具类与算法"],path:"/series/java/05-collections/05-collections-algorithms.html",content:"集合工具类与算法"},{title:"为什么需要泛型",headers:["为什么需要泛型"],path:"/series/java/06-generics/01-why-generics.html",content:"为什么需要泛型"},{title:"泛型方法与通配符",headers:["泛型方法与通配符"],path:"/series/java/06-generics/02-generic-methods.html",content:"泛型方法与通配符"},{title:"线程基础",headers:["线程基础"],path:"/series/java/07-multithreading/01-thread-basics.html",content:"线程基础"},{title:"Runnable 与 Callable",headers:["Runnable 与 Callable"],path:"/series/java/07-multithreading/02-runnable.html",content:"Runnable 与 Callable"},{title:"线程安全",headers:["线程安全"],path:"/series/java/07-multithreading/03-thread-safety.html",content:"线程安全"},{title:"synchronized 关键字",headers:["synchronized 关键字"],path:"/series/java/07-multithreading/04-synchronized.html",content:"synchronized 关键字"},{title:"Lock 锁机制",headers:["Lock 锁机制"],path:"/series/java/07-multithreading/05-locks.html",content:"Lock 锁机制"},{title:"线程池",headers:["线程池"],path:"/series/java/07-multithreading/06-thread-pool.html",content:"线程池"},{title:"JVM 体系结构",headers:["JVM 体系结构"],path:"/series/java/08-jvm/01-jvm-architecture.html",content:"JVM 体系结构"},{title:"类加载机制",headers:["类加载机制"],path:"/series/java/08-jvm/02-class-loading.html",content:"类加载机制"},{title:"内存结构",headers:["内存结构"],path:"/series/java/08-jvm/03-memory-structure.html",content:"内存结构"},{title:"垃圾回收机制",headers:["垃圾回收机制"],path:"/series/java/08-jvm/04-gc.html",content:"垃圾回收机制"},{title:"JVM 调优",headers:["JVM 调优"],path:"/series/java/08-jvm/05-jvm-tuning.html",content:"JVM 调优"},{title:"Lambda 表达式",headers:["Lambda 表达式"],path:"/series/java/09-java8-features/01-lambda.html",content:"Lambda 表达式"},{title:"Stream API",headers:["Stream API"],path:"/series/java/09-java8-features/02-stream.html",content:"Stream API"},{title:"新日期时间 API",headers:["新日期时间 API"],path:"/series/java/09-java8-features/03-new-date-api.html",content:"新日期时间 API"},{title:"Spring IoC 容器",headers:["Spring IoC 容器"],path:"/series/java/10-spring/01-spring-ioc.html",content:"Spring IoC 容器"},{title:"Spring AOP 面向切面编程",headers:["Spring AOP 面向切面编程"],path:"/series/java/10-spring/02-spring-aop.html",content:"Spring AOP 面向切面编程"},{title:"Spring Boot 入门",headers:["Spring Boot 入门"],path:"/series/java/10-spring/03-spring-boot-intro.html",content:"Spring Boot 入门"},{title:"Spring MVC 原理",headers:["Spring MVC 原理"],path:"/series/java/10-spring/04-spring-mvc.html",content:"Spring MVC 原理"},{title:"JDBC 数据库连接",headers:["JDBC 数据库连接"],path:"/series/java/11-database/01-jdbc.html",content:"JDBC 数据库连接"},{title:"MyBatis 持久层框架",headers:["MyBatis 持久层框架"],path:"/series/java/11-database/02-mybatis.html",content:"MyBatis 持久层框架"},{title:"Spring Data JPA",headers:["Spring Data JPA"],path:"/series/java/11-database/03-spring-data-jpa.html",content:"Spring Data JPA"},{title:"项目环境准备",headers:["项目环境准备"],path:"/series/java/12-project/01-project-env.html",content:"项目环境准备"},{title:"后端 API 设计",headers:["后端 API 设计"],path:"/series/java/12-project/02-backend-api-design.html",content:"后端 API 设计"},{title:"Spring Boot 项目实战",headers:["Spring Boot 项目实战"],path:"/series/java/12-project/03-spring-boot-demo.html",content:"Spring Boot 项目实战"},{title:"项目部署上线",headers:["项目部署上线"],path:"/series/java/12-project/04-deploy.html",content:"项目部署上线"}];export{e as default};
