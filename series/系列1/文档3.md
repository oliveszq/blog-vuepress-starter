---
title: 资源加载优化
date: 2024-08-22
categories:
    - frontend-optimization
tags:
    - performance
    - images
    - fonts
    - resources
    - optimization
series: 前端优化实战
sticky: 0
isShowComments: true
---

# 资源加载优化

资源加载优化是前端性能优化的重要组成部分。合理优化图片、字体、视频等资源的加载，可以显著提升页面加载速度和用户体验。

## 图片优化

### 1. 选择合适的图片格式

不同场景应选择不同的图片格式：

- **WebP**：现代浏览器支持，体积小，质量高
- **AVIF**：最新的图片格式，压缩率更高
- **JPEG**：适合照片和复杂图像
- **PNG**：适合图标和需要透明度的图像
- **SVG**：适合图标和简单图形

```html
<!-- 使用 picture 元素提供多种格式 -->
<picture>
    <source srcset="image.avif" type="image/avif">
    <source srcset="image.webp" type="image/webp">
    <img src="image.jpg" alt="描述">
</picture>
```

### 2. 响应式图片

使用 `srcset` 和 `sizes` 属性提供不同尺寸的图片。

```html
<img 
    srcset="
        image-small.jpg 400w,
        image-medium.jpg 800w,
        image-large.jpg 1200w
    "
    sizes="(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px"
    src="image-medium.jpg"
    alt="响应式图片"
>
```

### 3. 图片懒加载

使用原生 `loading="lazy"` 属性或 Intersection Observer API。

```html
<!-- 原生懒加载 -->
<img src="image.jpg" alt="描述" loading="lazy">

<!-- 使用 Intersection Observer -->
<img data-src="image.jpg" alt="描述" class="lazy">
```

```javascript
// Intersection Observer 实现
const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
        }
    });
});

document.querySelectorAll('img.lazy').forEach(img => {
    imageObserver.observe(img);
});
```

### 4. 图片压缩

使用工具压缩图片，减少文件大小：

- **在线工具**：TinyPNG、Squoosh
- **构建工具**：imagemin、sharp
- **CDN 服务**：Cloudinary、ImageKit

### 5. 使用 CSS Sprites

将多个小图标合并为一张图片，减少 HTTP 请求。

```css
.icon {
    background-image: url('sprite.png');
    background-size: 200px 200px;
}

.icon-home {
    background-position: 0 0;
    width: 50px;
    height: 50px;
}
```

## 字体优化

### 1. 字体子集化

只加载需要的字符，减少字体文件大小。

```css
/* 使用 unicode-range 指定字符范围 */
@font-face {
    font-family: 'CustomFont';
    src: url('font-subset.woff2') format('woff2');
    unicode-range: U+0020-007F; /* 只包含 ASCII 字符 */
}
```

### 2. 字体显示策略

使用 `font-display` 控制字体加载行为。

```css
@font-face {
    font-family: 'CustomFont';
    src: url('font.woff2') format('woff2');
    font-display: swap; /* swap: 立即显示备用字体 */
}
```

可选值：
- `auto`：浏览器默认行为
- `block`：阻塞文本显示直到字体加载完成
- `swap`：立即显示备用字体，字体加载后替换
- `fallback`：短暂阻塞后显示备用字体
- `optional`：如果字体未加载，使用备用字体

### 3. 预加载关键字体

```html
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
```

### 4. 使用系统字体栈

对于非关键文本，使用系统字体可以避免加载外部字体。

```css
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 
                 'Roboto', 'Helvetica Neue', Arial, sans-serif;
}
```

## 其他资源优化

### 1. 资源预加载

使用 `preload`、`prefetch` 和 `preconnect` 优化资源加载。

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="hero-image.jpg" as="image">

<!-- 预连接外部域名 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="dns-prefetch" href="https://api.example.com">

<!-- 预取可能需要的资源 -->
<link rel="prefetch" href="next-page.html">
```

### 2. 资源优先级

使用 `fetchpriority` 提示浏览器资源优先级。

```html
<img src="hero.jpg" alt="Hero" fetchpriority="high">
<img src="thumbnail.jpg" alt="Thumbnail" fetchpriority="low">
```

### 3. 使用 CDN

将静态资源部署到 CDN，利用地理分布提升加载速度。

```html
<!-- 使用 CDN 加载资源 -->
<script src="https://cdn.example.com/library.js"></script>
<link rel="stylesheet" href="https://cdn.example.com/styles.css">
```

### 4. 资源压缩

启用 Gzip 或 Brotli 压缩。

```nginx
# Nginx 配置
gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;
```

### 5. HTTP/2 和 HTTP/3

使用 HTTP/2 的多路复用和 HTTP/3 的 QUIC 协议提升性能。

## 缓存策略

### 1. 浏览器缓存

设置合适的缓存头。

```nginx
# 静态资源长期缓存
location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

# HTML 文件不缓存或短期缓存
location ~* \.html$ {
    expires 1h;
    add_header Cache-Control "public, must-revalidate";
}
```

### 2. Service Worker 缓存

使用 Service Worker 实现更灵活的缓存策略。

```javascript
// service-worker.js
self.addEventListener('fetch', (event) => {
    if (event.request.destination === 'image') {
        event.respondWith(
            caches.match(event.request).then((response) => {
                return response || fetch(event.request).then((fetchResponse) => {
                    return caches.open('images').then((cache) => {
                        cache.put(event.request, fetchResponse.clone());
                        return fetchResponse;
                    });
                });
            })
        );
    }
});
```

## 监控和测量

### 使用 Resource Timing API

```javascript
// 测量资源加载时间
const resources = performance.getEntriesByType('resource');
resources.forEach(resource => {
    console.log(`${resource.name}: ${resource.duration}ms`);
});
```

### 使用 Network Information API

```javascript
// 检测网络状况
const connection = navigator.connection || navigator.mozConnection;
if (connection) {
    console.log('网络类型:', connection.effectiveType);
    console.log('下行速度:', connection.downlink);
    
    // 根据网络状况调整资源加载
    if (connection.effectiveType === 'slow-2g') {
        // 加载低质量图片
    }
}
```

## 总结

资源加载优化要点：

1. **选择合适的格式**：根据场景选择最优的资源格式
2. **延迟加载**：非关键资源使用懒加载
3. **预加载关键资源**：使用 preload 和 preconnect
4. **合理使用缓存**：设置合适的缓存策略
5. **监控和测量**：持续监控资源加载性能

---

**系列总结**：通过本系列的学习，你已经掌握了前端性能优化的基础知识。继续实践和探索，将优化技巧应用到实际项目中！

