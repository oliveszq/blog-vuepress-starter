---
title: 组件通信进阶
date: 2024-08-21
categories:
    - vue
    - frontend
tags:
    - vue3
    - components
    - communication
series: Vue.js 进阶指南
sticky: 0
isShowComments: true
---

# 组件通信进阶

在 Vue 应用中，组件之间的通信是一个重要的话题。Vue 提供了多种方式来实现组件通信，不同的场景应该选择合适的方式。

## 父子组件通信

### Props 和 Events

最基础的父子组件通信方式。

**父组件：**

```vue
<template>
    <ChildComponent 
        :message="parentMessage"
        @update="handleUpdate"
    />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentMessage = ref('Hello from parent')

const handleUpdate = (newValue) => {
    parentMessage.value = newValue
}
</script>
```

**子组件：**

```vue
<template>
    <div>
        <p>{{ message }}</p>
        <button @click="updateParent">更新父组件</button>
    </div>
</template>

<script setup>
defineProps({
    message: String
})

const emit = defineEmits(['update'])

const updateParent = () => {
    emit('update', 'New value from child')
}
</script>
```

### v-model

`v-model` 是 `props` 和 `emit` 的语法糖。

**父组件：**

```vue
<template>
    <CustomInput v-model="inputValue" />
</template>

<script setup>
import { ref } from 'vue'
import CustomInput from './CustomInput.vue'

const inputValue = ref('')
</script>
```

**子组件：**

```vue
<template>
    <input 
        :value="modelValue"
        @input="$emit('update:modelValue', $event.target.value)"
    />
</template>

<script setup>
defineProps({
    modelValue: String
})

defineEmits(['update:modelValue'])
</script>
```

### 多个 v-model

Vue 3 支持多个 `v-model`：

```vue
<template>
    <CustomForm 
        v-model:name="name"
        v-model:email="email"
    />
</template>
```

## 跨层级组件通信

### provide / inject

用于跨层级组件通信，避免 props 逐层传递。

**祖先组件：**

```vue
<template>
    <Parent>
        <Child />
    </Parent>
</template>

<script setup>
import { provide, ref } from 'vue'
import Parent from './Parent.vue'
import Child from './Child.vue'

const theme = ref('dark')

provide('theme', theme)
provide('updateTheme', (newTheme) => {
    theme.value = newTheme
})
</script>
```

**后代组件：**

```vue
<template>
    <div :class="theme">
        <button @click="toggleTheme">切换主题</button>
    </div>
</template>

<script setup>
import { inject } from 'vue'

const theme = inject('theme')
const updateTheme = inject('updateTheme')

const toggleTheme = () => {
    updateTheme(theme.value === 'dark' ? 'light' : 'dark')
}
</script>
```

### 使用 Symbol 作为 key

避免命名冲突：

```javascript
// keys.js
export const THEME_KEY = Symbol('theme')
export const USER_KEY = Symbol('user')

// 祖先组件
import { provide } from 'vue'
import { THEME_KEY } from './keys'

provide(THEME_KEY, 'dark')

// 后代组件
import { inject } from 'vue'
import { THEME_KEY } from './keys'

const theme = inject(THEME_KEY)
```

## 全局状态管理

### 使用组合式函数

对于简单的全局状态，可以使用组合式函数：

```javascript
// stores/user.js
import { ref } from 'vue'

const user = ref(null)

export function useUser() {
    const setUser = (userData) => {
        user.value = userData
    }

    const clearUser = () => {
        user.value = null
    }

    return {
        user: readonly(user),
        setUser,
        clearUser
    }
}
```

### Pinia（推荐）

Pinia 是 Vue 的官方状态管理库。

**安装：**

```bash
npm install pinia
```

**创建 store：**

```javascript
// stores/user.js
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
    state: () => ({
        name: '',
        email: ''
    }),
    getters: {
        fullName: (state) => `${state.name} (${state.email})`
    },
    actions: {
        setUser(name, email) {
            this.name = name
            this.email = email
        }
    }
})
```

**在组件中使用：**

```vue
<template>
    <div>
        <p>{{ userStore.fullName }}</p>
        <button @click="updateUser">更新用户</button>
    </div>
</template>

<script setup>
import { useUserStore } from './stores/user'

const userStore = useUserStore()

const updateUser = () => {
    userStore.setUser('John', 'john@example.com')
}
</script>
```

## 事件总线（Event Bus）

虽然 Vue 3 移除了 `$on` 和 `$off`，但可以使用第三方库实现事件总线：

```javascript
// eventBus.js
import mitt from 'mitt'

export const eventBus = mitt()

// 组件 A
import { eventBus } from './eventBus'

eventBus.emit('custom-event', { data: 'value' })

// 组件 B
import { eventBus } from './eventBus'

eventBus.on('custom-event', (data) => {
    console.log(data)
})
```

## 使用 ref 访问子组件

通过 `ref` 可以直接访问子组件的实例和方法：

**父组件：**

```vue
<template>
    <ChildComponent ref="childRef" />
    <button @click="callChildMethod">调用子组件方法</button>
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const childRef = ref(null)

const callChildMethod = () => {
    childRef.value?.someMethod()
}
</script>
```

**子组件：**

```vue
<script setup>
import { defineExpose } from 'vue'

const someMethod = () => {
    console.log('子组件方法被调用')
}

// 暴露方法给父组件
defineExpose({
    someMethod
})
</script>
```

## 插槽（Slots）

插槽用于内容分发，实现更灵活的组件组合。

### 默认插槽

```vue
<!-- 子组件 -->
<template>
    <div class="card">
        <slot></slot>
    </div>
</template>

<!-- 父组件 -->
<Card>
    <p>这是插槽内容</p>
</Card>
```

### 具名插槽

```vue
<!-- 子组件 -->
<template>
    <div class="layout">
        <header>
            <slot name="header"></slot>
        </header>
        <main>
            <slot></slot>
        </main>
        <footer>
            <slot name="footer"></slot>
        </footer>
    </div>
</template>

<!-- 父组件 -->
<Layout>
    <template #header>
        <h1>标题</h1>
    </template>
    
    <p>主要内容</p>
    
    <template #footer>
        <p>页脚</p>
    </template>
</Layout>
```

### 作用域插槽

子组件向插槽传递数据：

```vue
<!-- 子组件 -->
<template>
    <ul>
        <li v-for="item in items" :key="item.id">
            <slot :item="item" :index="index"></slot>
        </li>
    </ul>
</template>

<!-- 父组件 -->
<ItemList>
    <template #default="{ item, index }">
        <span>{{ index }}: {{ item.name }}</span>
    </template>
</ItemList>
```

## 通信方式选择指南

| 场景 | 推荐方式 |
|------|---------|
| 父子组件通信 | Props / Events |
| 双向绑定 | v-model |
| 跨层级通信 | provide / inject |
| 全局状态 | Pinia |
| 简单全局状态 | 组合式函数 |
| 组件方法调用 | ref + defineExpose |
| 内容分发 | Slots |

## 最佳实践

### 1. 优先使用 Props 和 Events

对于父子组件通信，优先使用 props 和 events，这是最直接和可维护的方式。

### 2. 避免过度使用 provide / inject

只在真正需要跨层级通信时使用，避免滥用导致代码难以追踪。

### 3. 合理使用状态管理

- 简单状态：使用组合式函数
- 复杂状态：使用 Pinia
- 避免在组件中直接修改 store 的 state

### 4. 使用 TypeScript

为 props、emits 等添加类型定义：

```typescript
interface Props {
    message: string
    count?: number
}

const props = withDefaults(defineProps<Props>(), {
    count: 0
})

const emit = defineEmits<{
    update: [value: string]
}>()
```

## 总结

Vue 提供了丰富的组件通信方式：

1. **Props / Events**：父子组件通信的基础
2. **v-model**：双向绑定的语法糖
3. **provide / inject**：跨层级通信
4. **Pinia**：全局状态管理
5. **ref + defineExpose**：访问子组件
6. **Slots**：内容分发

选择合适的通信方式，可以让代码更加清晰和可维护。

---

**下一步**：阅读 [Vue 性能优化实践](/series/系列2/文档4)，学习如何优化 Vue 应用的性能。

