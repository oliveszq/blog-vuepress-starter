---
title: Vue 性能优化实践
date: 2024-08-22
categories:
    - vue
    - frontend
tags:
    - vue3
    - performance
    - optimization
series: Vue.js 进阶指南
sticky: 0
isShowComments: true
---

# Vue 性能优化实践

性能优化是构建高质量 Vue 应用的关键。本文将介绍 Vue 应用中的各种性能优化技巧和最佳实践。

## 组件优化

### 1. 使用 v-once

对于静态内容，使用 `v-once` 只渲染一次：

```vue
<template>
    <div>
        <h1 v-once>{{ staticTitle }}</h1>
        <p v-once>{{ staticContent }}</p>
    </div>
</template>
```

### 2. 使用 v-memo

Vue 3.2+ 新增的 `v-memo` 可以缓存模板的一部分：

```vue
<template>
    <div v-for="item in list" :key="item.id" v-memo="[item.id, item.selected]">
        <p>{{ item.name }}</p>
        <span v-if="item.selected">已选择</span>
    </div>
</template>
```

只有当 `item.id` 或 `item.selected` 变化时，才会重新渲染该元素。

### 3. 合理使用 v-if 和 v-show

- `v-if`：条件为 false 时不渲染，适合切换频率低的情况
- `v-show`：始终渲染，只是切换 display，适合切换频率高的情况

```vue
<!-- 切换频率低，使用 v-if -->
<div v-if="showExpensiveComponent">
    <ExpensiveComponent />
</div>

<!-- 切换频率高，使用 v-show -->
<div v-show="isVisible">
    频繁切换的内容
</div>
```

### 4. 使用异步组件

对于大型组件，使用异步组件延迟加载：

```javascript
// 方式 1：使用 defineAsyncComponent
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() => 
    import('./HeavyComponent.vue')
)

// 方式 2：直接使用动态导入
export default {
    components: {
        HeavyComponent: () => import('./HeavyComponent.vue')
    }
}
```

### 5. 组件懒加载

路由级别的懒加载：

```javascript
// router.js
const routes = [
    {
        path: '/home',
        component: () => import('./views/Home.vue')
    },
    {
        path: '/about',
        component: () => import('./views/About.vue')
    }
]
```

## 列表渲染优化

### 1. 使用 key

始终为 `v-for` 提供唯一的 `key`：

```vue
<template>
    <div v-for="item in items" :key="item.id">
        {{ item.name }}
    </div>
</template>
```

### 2. 避免在模板中使用复杂计算

```vue
<!-- 不好的做法 -->
<template>
    <div v-for="item in items" :key="item.id">
        {{ expensiveComputation(item) }}
    </div>
</template>

<!-- 优化后 -->
<template>
    <div v-for="item in computedItems" :key="item.id">
        {{ item.computedValue }}
    </div>
</template>

<script setup>
import { computed } from 'vue'

const computedItems = computed(() => {
    return items.value.map(item => ({
        ...item,
        computedValue: expensiveComputation(item)
    }))
})
</script>
```

### 3. 虚拟滚动

对于长列表，使用虚拟滚动：

```vue
<template>
    <VirtualList
        :items="items"
        :item-height="50"
        :container-height="400"
    >
        <template #default="{ item }">
            <ListItem :item="item" />
        </template>
    </VirtualList>
</template>
```

## 计算属性和侦听器优化

### 1. 使用 computed 而不是 methods

对于依赖响应式数据的计算，使用 `computed`：

```vue
<!-- 不好的做法 -->
<template>
    <div>{{ getFullName() }}</div>
</template>

<script setup>
const getFullName = () => {
    return `${firstName.value} ${lastName.value}`
}
</script>

<!-- 优化后 -->
<template>
    <div>{{ fullName }}</div>
</template>

<script setup>
import { computed } from 'vue'

const fullName = computed(() => {
    return `${firstName.value} ${lastName.value}`
})
</script>
```

### 2. 避免在 computed 中执行副作用

```javascript
// 不好的做法
const badComputed = computed(() => {
    console.log('副作用') // 不应该在 computed 中执行副作用
    return someValue.value
})

// 应该使用 watch 或 watchEffect
watchEffect(() => {
    console.log('副作用')
    // ...
})
```

### 3. 合理使用 watch 选项

```javascript
// 立即执行
watch(source, callback, { immediate: true })

// 深度监听（谨慎使用）
watch(source, callback, { deep: true })

// 只监听特定属性
watch(() => obj.value.nested.prop, callback)
```

## 响应式数据优化

### 1. 使用 shallowRef 和 shallowReactive

对于不需要深度响应式的数据，使用 `shallowRef` 或 `shallowReactive`：

```javascript
import { shallowRef, shallowReactive } from 'vue'

// 只对 .value 的变化响应
const largeObject = shallowRef({ /* 大量数据 */ })

// 只对第一层属性变化响应
const state = shallowReactive({
    nested: {
        deep: 'value' // 这个变化不会触发响应
    }
})
```

### 2. 使用 markRaw

标记对象为非响应式：

```javascript
import { markRaw } from 'vue'

const chart = markRaw(new Chart(...))
// chart 的变化不会触发响应式更新
```

### 3. 避免创建不必要的响应式对象

```javascript
// 不好的做法：所有数据都是响应式的
const state = reactive({
    staticData: { /* 大量静态数据 */ },
    dynamicData: { /* 需要响应式的数据 */ }
})

// 优化后：只对需要的数据使用响应式
const staticData = { /* 静态数据 */ }
const dynamicData = reactive({ /* 响应式数据 */ })
```

## 事件处理优化

### 1. 使用事件修饰符

```vue
<!-- 阻止默认行为 -->
<form @submit.prevent="handleSubmit">

<!-- 阻止冒泡 -->
<div @click.stop="handleClick">

<!-- 只触发一次 -->
<button @click.once="handleClick">
```

### 2. 防抖和节流

```javascript
import { debounce } from 'lodash-es'

// 在 setup 中
const handleSearch = debounce((query) => {
    // 搜索逻辑
}, 300)
```

或者使用组合式函数：

```javascript
// composables/useDebounce.js
import { ref } from 'vue'

export function useDebounce(fn, delay = 300) {
    let timeoutId
    return function(...args) {
        clearTimeout(timeoutId)
        timeoutId = setTimeout(() => fn.apply(this, args), delay)
    }
}
```

## 构建优化

### 1. 代码分割

使用动态导入实现代码分割：

```javascript
// 路由懒加载
const Home = () => import('./views/Home.vue')

// 组件懒加载
const HeavyComponent = () => import('./components/Heavy.vue')

// 条件加载
if (condition) {
    const module = await import('./module.js')
}
```

### 2. Tree Shaking

确保使用具名导入：

```javascript
// 好的做法：Tree shaking 可以移除未使用的代码
import { debounce, throttle } from 'lodash-es'

// 不好的做法：导入整个库
import _ from 'lodash'
```

### 3. 使用生产构建

```bash
# 开发环境
npm run dev

# 生产环境（启用压缩和优化）
npm run build
```

### 4. 分析打包体积

```bash
# 使用 vite-bundle-visualizer
npm install -D vite-bundle-visualizer

# 在 vite.config.js 中配置
import { visualizer } from 'vite-bundle-visualizer'

export default {
    plugins: [
        visualizer()
    ]
}
```

## 运行时优化

### 1. 使用 keep-alive

缓存组件实例，避免重复渲染：

```vue
<template>
    <keep-alive>
        <component :is="currentComponent" />
    </keep-alive>
</template>
```

### 2. 使用 Object.freeze

冻结不需要响应式的数据：

```javascript
const staticData = Object.freeze({
    items: [/* ... */]
})
```

### 3. 避免在模板中使用函数

```vue
<!-- 不好的做法：每次渲染都会创建新函数 -->
<template>
    <div v-for="item in items" :key="item.id">
        <button @click="() => handleClick(item.id)">点击</button>
    </div>
</template>

<!-- 优化后：使用 methods -->
<template>
    <div v-for="item in items" :key="item.id">
        <button @click="handleClick(item.id)">点击</button>
    </div>
</template>
```

## 性能监控

### 1. 使用 Performance API

```javascript
// 测量组件渲染时间
export default {
    setup() {
        onMounted(() => {
            const start = performance.now()
            // 组件逻辑
            const end = performance.now()
            console.log(`渲染时间: ${end - start}ms`)
        })
    }
}
```

### 2. 使用 Vue DevTools

Vue DevTools 提供了性能分析功能，可以查看组件渲染时间、更新频率等。

### 3. 使用 Lighthouse

定期使用 Lighthouse 进行性能审计。

## 总结

Vue 性能优化要点：

1. **组件优化**：使用异步组件、v-once、v-memo 等
2. **列表优化**：提供 key、使用虚拟滚动
3. **计算优化**：合理使用 computed 和 watch
4. **响应式优化**：避免不必要的响应式数据
5. **构建优化**：代码分割、Tree shaking
6. **运行时优化**：keep-alive、事件优化

性能优化是一个持续的过程，需要根据实际情况选择合适的方法。

---

**系列总结**：通过本系列的学习，你已经掌握了 Vue.js 的核心概念和进阶技巧。继续实践，将这些知识应用到实际项目中，构建更好的 Vue 应用！

