---
title: Vue 3 组合式 API 深入理解
date: 2024-08-20
categories:
    - vue
    - frontend
tags:
    - vue3
    - composition-api
    - javascript
series: Vue.js 进阶指南
sticky: 0
isShowComments: true
---

# Vue 3 组合式 API 深入理解

Vue 3 引入了组合式 API（Composition API），这是 Vue.js 发展史上的重要里程碑。组合式 API 提供了更灵活、更强大的代码组织方式，特别适合构建大型应用。

## 为什么需要组合式 API？

### 选项式 API 的局限性

在 Vue 2 的选项式 API 中，相关的逻辑被分散在不同的选项中：

```javascript
export default {
    data() {
        return {
            count: 0,
            message: 'Hello'
        }
    },
    methods: {
        increment() {
            this.count++
        },
        updateMessage() {
            this.message = 'Updated'
        }
    },
    computed: {
        doubleCount() {
            return this.count * 2
        }
    }
}
```

当组件变得复杂时，相关的逻辑代码会分散在 `data`、`methods`、`computed` 等不同选项中，难以维护。

### 组合式 API 的优势

组合式 API 允许我们将相关的逻辑组织在一起：

```javascript
import { ref, computed } from 'vue'

export default {
    setup() {
        // 计数器相关逻辑
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        const increment = () => {
            count.value++
        }

        // 消息相关逻辑
        const message = ref('Hello')
        const updateMessage = () => {
            message.value = 'Updated'
        }

        return {
            count,
            doubleCount,
            increment,
            message,
            updateMessage
        }
    }
}
```

## 核心概念

### 1. setup() 函数

`setup()` 是组合式 API 的入口点，在组件创建之前执行。

```javascript
export default {
    setup(props, context) {
        // props: 组件接收的属性
        // context: 包含 attrs、slots、emit 等

        // 返回的数据和方法可以在模板中使用
        return {
            // ...
        }
    }
}
```

### 2. 响应式基础

#### ref

`ref` 用于创建响应式的原始值。

```javascript
import { ref } from 'vue'

const count = ref(0)
console.log(count.value) // 0

count.value = 1
console.log(count.value) // 1
```

#### reactive

`reactive` 用于创建响应式的对象。

```javascript
import { reactive } from 'vue'

const state = reactive({
    count: 0,
    message: 'Hello'
})

state.count++
state.message = 'Updated'
```

#### 区别

- `ref` 可以用于任何类型，需要通过 `.value` 访问
- `reactive` 只能用于对象，可以直接访问属性

### 3. 计算属性

使用 `computed` 创建计算属性。

```javascript
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)

// 可写的计算属性
const fullName = computed({
    get() {
        return `${firstName.value} ${lastName.value}`
    },
    set(newValue) {
        [firstName.value, lastName.value] = newValue.split(' ')
    }
})
```

### 4. 侦听器

#### watch

```javascript
import { ref, watch } from 'vue'

const count = ref(0)

watch(count, (newValue, oldValue) => {
    console.log(`count 从 ${oldValue} 变为 ${newValue}`)
})

// 监听多个源
watch([count, message], ([newCount, newMessage], [oldCount, oldMessage]) => {
    // ...
})
```

#### watchEffect

`watchEffect` 会自动追踪依赖，并在依赖变化时重新执行。

```javascript
import { ref, watchEffect } from 'vue'

const count = ref(0)

watchEffect(() => {
    console.log(`count 是 ${count.value}`)
    // 会自动追踪 count，当 count 变化时重新执行
})
```

### 5. 生命周期钩子

组合式 API 提供了对应的生命周期钩子：

```javascript
import { onMounted, onUpdated, onUnmounted } from 'vue'

export default {
    setup() {
        onMounted(() => {
            console.log('组件已挂载')
        })

        onUpdated(() => {
            console.log('组件已更新')
        })

        onUnmounted(() => {
            console.log('组件已卸载')
        })
    }
}
```

生命周期对应关系：

- `beforeCreate` → `setup()`
- `created` → `setup()`
- `beforeMount` → `onBeforeMount`
- `mounted` → `onMounted`
- `beforeUpdate` → `onBeforeUpdate`
- `updated` → `onUpdated`
- `beforeUnmount` → `onBeforeUnmount`
- `unmounted` → `onUnmounted`

## 组合式函数（Composables）

组合式函数是组合式 API 的核心特性，用于提取和复用逻辑。

### 示例：鼠标位置追踪

```javascript
// composables/useMouse.js
import { ref, onMounted, onUnmounted } from 'vue'

export function useMouse() {
    const x = ref(0)
    const y = ref(0)

    function update(event) {
        x.value = event.pageX
        y.value = event.pageY
    }

    onMounted(() => {
        window.addEventListener('mousemove', update)
    })

    onUnmounted(() => {
        window.removeEventListener('mousemove', update)
    })

    return { x, y }
}
```

使用：

```javascript
import { useMouse } from './composables/useMouse'

export default {
    setup() {
        const { x, y } = useMouse()
        return { x, y }
    }
}
```

### 示例：异步数据获取

```javascript
// composables/useFetch.js
import { ref } from 'vue'

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    const loading = ref(false)

    async function fetchData() {
        loading.value = true
        error.value = null
        try {
            const response = await fetch(url)
            data.value = await response.json()
        } catch (e) {
            error.value = e
        } finally {
            loading.value = false
        }
    }

    fetchData()

    return { data, error, loading, refetch: fetchData }
}
```

## 与选项式 API 的对比

### 选项式 API

```javascript
export default {
    data() {
        return {
            count: 0
        }
    },
    methods: {
        increment() {
            this.count++
        }
    },
    mounted() {
        console.log('mounted')
    }
}
```

### 组合式 API

```javascript
import { ref, onMounted } from 'vue'

export default {
    setup() {
        const count = ref(0)
        
        const increment = () => {
            count.value++
        }

        onMounted(() => {
            console.log('mounted')
        })

        return {
            count,
            increment
        }
    }
}
```

## 最佳实践

### 1. 使用 `<script setup>`

`<script setup>` 是组合式 API 的语法糖，更简洁：

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
const increment = () => {
    count.value++
}
</script>

<template>
    <button @click="increment">{{ count }}</button>
</template>
```

### 2. 合理组织代码

```javascript
// 按功能组织
export default {
    setup() {
        // 功能 A
        const { dataA, methodA } = useFeatureA()
        
        // 功能 B
        const { dataB, methodB } = useFeatureB()
        
        return {
            dataA,
            methodA,
            dataB,
            methodB
        }
    }
}
```

### 3. 使用 TypeScript

组合式 API 对 TypeScript 有更好的支持：

```typescript
import { ref, Ref } from 'vue'

function useCounter(): { count: Ref<number>, increment: () => void } {
    const count = ref<number>(0)
    const increment = () => {
        count.value++
    }
    return { count, increment }
}
```

## 总结

组合式 API 提供了：

1. **更好的逻辑复用**：通过组合式函数提取和复用逻辑
2. **更灵活的组织方式**：相关逻辑可以组织在一起
3. **更好的 TypeScript 支持**：类型推断更准确
4. **更小的包体积**：Tree-shaking 更有效

虽然组合式 API 功能强大，但选项式 API 仍然可以使用。选择哪种方式取决于项目需求和团队偏好。

---

**下一步**：阅读 [组件通信进阶](/series/系列2/文档3)，学习 Vue 中各种组件通信方式。

